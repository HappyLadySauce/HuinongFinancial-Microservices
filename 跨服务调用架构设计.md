# 🚀 跨服务调用架构设计

## 📋 概述

基于go-zero微服务架构的RPC间跨服务调用设计，通过consul服务发现实现服务间通信。

## 🏗️ 服务架构

### **服务发现架构**
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Consul集群    │    │   Consul集群    │    │   Consul集群    │
│ consul.huinong │────│ consul.huinong │────│ consul.huinong │
│   .internal    │    │   .internal    │    │   .internal    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
    ┌────────────────────────────┴────────────────────────────┐
    │                  服务注册中心                           │
    └────────────────────────────┬────────────────────────────┘
                                 │
         ┌───────────────────────┼───────────────────────┐
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   AppUser RPC   │    │   Lease RPC     │    │   Loan RPC      │
│   端口: 20001    │    │   端口: 20004    │    │   端口: 20002    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│LeaseProduct RPC │    │LoanProduct RPC  │    │   OAUser RPC    │
│   端口: 20006    │    │   端口: 20005    │    │   端口: 20003    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### **服务依赖关系**
```
┌─────────────┐    调用    ┌─────────────┐
│  Lease RPC  │────────►│ AppUser RPC │
│             │         │             │
│             │    调用    ┌─────────────┐
│             │────────►│LeaseProduct │
│             │         │    RPC      │
└─────────────┘         └─────────────┘

┌─────────────┐    调用    ┌─────────────┐
│  Loan RPC   │────────►│ AppUser RPC │
│             │         │             │
│             │    调用    ┌─────────────┐
│             │────────►│LoanProduct  │
│             │         │    RPC      │
└─────────────┘         └─────────────┘
```

## 🔧 跨服务调用接口设计

### **1. AppUser RPC - 用户服务**

#### **服务配置**
```yaml
Name: appuser.rpc
ListenOn: 0.0.0.0:20001
Etcd:
  Hosts:
    - consul.huinong.internal:2379
  Key: appuser.rpc
```

#### **核心接口**
```protobuf
service AppUser {
    // 通过手机号获取用户信息
    rpc GetUserByPhone(GetUserInfoReq) returns (GetUserInfoResp);
    
    // 通过用户ID获取用户信息 (新增 - 用于跨服务调用)
    rpc GetUserById(GetUserByIdReq) returns (GetUserInfoResp);
    
    // 其他认证管理接口...
}

// 通过用户ID获取用户信息 - 新增接口
message GetUserByIdReq {
    int64 user_id = 1;
}

message GetUserInfoResp {
    int32 code = 1;
    string message = 2;
    UserInfo user_info = 3;  // 包含name字段用于获取用户姓名
}
```

### **2. LeaseProduct RPC - 租赁产品服务**

#### **服务配置**
```yaml
Name: leaseproductrpc.rpc
ListenOn: 0.0.0.0:20006
Etcd:
  Hosts:
    - consul.huinong.internal:2379
  Key: leaseproductrpc.rpc
```

#### **核心接口**
```protobuf
service LeaseProductService {
    // 产品信息查询
    rpc GetLeaseProduct(GetLeaseProductReq) returns (GetLeaseProductResp);
    
    // 库存可用性检查 (关键接口)
    rpc CheckInventoryAvailability(CheckInventoryAvailabilityReq) returns (CheckInventoryAvailabilityResp);
}

message CheckInventoryAvailabilityReq {
    string productCode = 1;     // 产品编码
    int32 quantity = 2;         // 需要数量
    string startDate = 3;       // 开始日期
    string endDate = 4;         // 结束日期
}

message CheckInventoryAvailabilityResp {
    int32 code = 1;
    string message = 2;
    bool available = 3;         // 是否可用
    int32 availableCount = 4;   // 可用数量
}
```

### **3. LoanProduct RPC - 贷款产品服务**

#### **服务配置**
```yaml
Name: loanproductrpc.rpc
ListenOn: 0.0.0.0:20005
Etcd:
  Hosts:
    - consul.huinong.internal:2379
  Key: loanproductrpc.rpc
```

#### **核心接口**
```protobuf
service LoanProductService {
    // 通过ID或产品编码获取产品信息
    rpc GetLoanProduct(GetLoanProductReq) returns (GetLoanProductResp);
}

message GetLoanProductReq {
    int64 id = 1;               // 产品ID (可选)
    string productCode = 2;     // 产品编码 (可选)
}
```

## 🔗 跨服务调用实现

### **1. Lease RPC 跨服务调用**

#### **配置文件 (lease-rpc.yaml)**
```yaml
Name: lease.rpc
ListenOn: 0.0.0.0:20004
Etcd:
  Hosts:
    - consul.huinong.internal:2379
  Key: lease.rpc

# RPC客户端配置
LeaseProductRpc:
  Etcd:
    Hosts:
      - consul.huinong.internal:2379
    Key: leaseproductrpc.rpc
    
AppUserRpc:
  Etcd:
    Hosts:
      - consul.huinong.internal:2379
    Key: appuser.rpc
```

#### **ServiceContext配置**
```go
type ServiceContext struct {
    Config                 config.Config
    LeaseApplicationsModel model.LeaseApplicationsModel
    LeaseApprovalsModel    model.LeaseApprovalsModel
    
    // RPC 客户端
    LeaseProductRpc leaseproduct.LeaseProductService  // 待生成
    AppUserRpc      appuser.AppUserService           // 待生成
}

func NewServiceContext(c config.Config) *ServiceContext {
    return &ServiceContext{
        Config: c,
        // ... 其他配置
        
        // 初始化RPC客户端
        LeaseProductRpc: leaseproduct.NewLeaseProductService(zrpc.MustNewClient(c.LeaseProductRpc)),
        AppUserRpc:      appuser.NewAppUserService(zrpc.MustNewClient(c.AppUserRpc)),
    }
}
```

#### **业务逻辑调用示例**
```go
func (l *CreateLeaseApplicationLogic) CreateLeaseApplication(in *lease.CreateLeaseApplicationReq) (*lease.CreateLeaseApplicationResp, error) {
    // 1. 验证用户信息
    userResp, err := l.svcCtx.AppUserRpc.GetUserById(l.ctx, &appuser.GetUserByIdReq{
        UserId: in.UserId,
    })
    if err != nil || userResp.Code != 200 {
        return &lease.CreateLeaseApplicationResp{
            Code:    400,
            Message: "用户信息验证失败",
        }, nil
    }
    
    // 2. 检查产品库存
    stockResp, err := l.svcCtx.LeaseProductRpc.CheckInventoryAvailability(l.ctx, &leaseproduct.CheckInventoryAvailabilityReq{
        ProductCode: in.ProductCode,
        Quantity:    1,
        StartDate:   in.StartDate,
        EndDate:     in.EndDate,
    })
    if err != nil || stockResp.Code != 200 || !stockResp.Available {
        return &lease.CreateLeaseApplicationResp{
            Code:    400,
            Message: "产品库存不足或时间段不可用",
        }, nil
    }
    
    // 3. 创建申请记录
    applicantName := userResp.UserInfo.Name
    // ... 创建逻辑
}
```

### **2. Loan RPC 跨服务调用**

#### **配置文件 (loan-rpc.yaml)**
```yaml
Name: loan.rpc
ListenOn: 0.0.0.0:20002
Etcd:
  Hosts:
    - consul.huinong.internal:2379
  Key: loan.rpc

# RPC客户端配置
LoanProductRpc:
  Etcd:
    Hosts:
      - consul.huinong.internal:2379
    Key: loanproductrpc.rpc
    
AppUserRpc:
  Etcd:
    Hosts:
      - consul.huinong.internal:2379
    Key: appuser.rpc
```

#### **业务逻辑调用示例**
```go
func (l *CreateLoanApplicationLogic) CreateLoanApplication(in *loan.CreateLoanApplicationReq) (*loan.CreateLoanApplicationResp, error) {
    // 1. 验证用户信息
    userResp, err := l.svcCtx.AppUserRpc.GetUserById(l.ctx, &appuser.GetUserByIdReq{
        UserId: in.UserId,
    })
    if err != nil || userResp.Code != 200 {
        return &loan.CreateLoanApplicationResp{
            Code:    400,
            Message: "用户信息验证失败",
        }, nil
    }
    
    // 2. 验证贷款产品信息
    productResp, err := l.svcCtx.LoanProductRpc.GetLoanProduct(l.ctx, &loanproduct.GetLoanProductReq{
        Id: in.ProductId,
    })
    if err != nil || productResp.Code != 200 {
        return &loan.CreateLoanApplicationResp{
            Code:    400,
            Message: "贷款产品信息验证失败",
        }, nil
    }
    
    // 3. 验证申请金额是否在产品限额内
    product := productResp.Data
    if in.Amount < product.MinAmount || in.Amount > product.MaxAmount {
        return &loan.CreateLoanApplicationResp{
            Code:    400,
            Message: "申请金额超出产品限额",
        }, nil
    }
    
    // 4. 创建申请记录
    applicantName := userResp.UserInfo.Name
    // ... 创建逻辑
}
```

## 📋 当前进度

### **✅ 已完成**
1. **Proto接口定义** - 所有服务的proto文件已完善
2. **配置架构** - ServiceContext和Config结构已就绪
3. **基础业务逻辑** - 核心CRUD操作已实现
4. **数据模型** - 所有自定义模型方法已添加

### **🔄 进行中**
1. **代码重新生成** - 正在重新生成所有RPC代码
2. **RPC客户端接口** - 等待生成的客户端接口

### **📋 待完成**
1. **真正的跨服务调用** - 替换当前的临时实现
2. **错误处理优化** - 完善RPC调用的错误处理
3. **配置文件完善** - 添加实际的服务发现配置
4. **集成测试** - 验证跨服务调用的正确性

## 🎯 实现要点

### **1. 服务发现**
- 所有服务通过consul注册和发现
- 使用go-zero的zrpc客户端自动负载均衡
- 服务健康检查和故障转移

### **2. 错误处理**
```go
// 统一的RPC调用错误处理
func callRemoteService(ctx context.Context, serviceName string, method func() error) error {
    if err := method(); err != nil {
        logx.Errorf("调用%s服务失败: %v", serviceName, err)
        return fmt.Errorf("%s服务暂时不可用", serviceName)
    }
    return nil
}
```

### **3. 超时控制**
```go
// 设置RPC调用超时
ctx, cancel := context.WithTimeout(l.ctx, 5*time.Second)
defer cancel()

userResp, err := l.svcCtx.AppUserRpc.GetUserById(ctx, req)
```

### **4. 重试机制**
```go
// 使用go-zero的重试中间件
AppUserRpc: zrpc.MustNewClient(c.AppUserRpc, 
    zrpc.WithRetry(retry.DoOnFailure(
        retry.Attempts(3),
        retry.Delay(100*time.Millisecond),
    )),
)
```

---

## 🌟 总结

这个跨服务调用架构提供了：

1. **🏗️ 标准化架构** - 基于go-zero和consul的标准微服务架构
2. **🚀 高性能** - gRPC协议和连接池优化
3. **🛡️ 高可用** - 服务发现、负载均衡、故障转移
4. **🔧 易扩展** - 清晰的接口定义和统一的调用模式
5. **📊 可观测** - 完整的日志记录和错误追踪

待代码重新生成完成后，我们将实现真正的跨服务调用逻辑，替换当前的临时实现。

---

*此文档展示了完整的跨服务调用架构设计，为微服务间通信提供了标准化的解决方案。* 