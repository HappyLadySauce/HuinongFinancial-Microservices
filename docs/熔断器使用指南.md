# 微服务熔断器使用指南

## 概述

本指南介绍如何在go-zero微服务项目中使用熔断器来提高系统的健壮性和可用性。熔断器可以防止级联故障，在依赖服务不可用时快速失败，保护整个服务链路。

## 配置优化

### 1. 懒加载客户端初始化

所有RPC客户端配置已优化为懒加载模式，避免启动时因依赖服务未就绪而失败：

```yaml
# 示例：loan RPC服务配置
AppUserRpc:
  Target: consul://consul.huinong.internal/appuserrpc.rpc
  LazyInit: true        # 懒加载：避免启动时因依赖服务未就绪而失败
  DialTimeout: 10s      # 连接超时：给依赖服务更多启动时间
  Timeout: 5s           # 调用超时：避免长时间等待
  KeepaliveTime: 30s    # 保活时间：减少连接重建开销
  NonBlock: true        # 非阻塞：启动时不等待连接建立
```

### 2. 配置参数说明

- **LazyInit: true**: 延迟初始化，仅在首次调用时建立连接
- **DialTimeout: 10s**: 连接超时时间，给依赖服务启动预留时间
- **Timeout: 5s**: 单次调用超时时间，避免长时间等待
- **KeepaliveTime: 30s**: 连接保活时间，减少重连开销
- **NonBlock: true**: 非阻塞模式，启动时不等待连接建立

## 熔断器使用

### 1. API层使用熔断器

API层调用RPC服务时使用熔断器，防止RPC服务故障影响API响应：

```go
package logic

import (
    "api/internal/breaker"
    "rpc/loanclient"
)

func (l *CreateLoanApplicationLogic) CreateLoanApplication(req *types.CreateLoanApplicationReq) (resp *types.CreateLoanApplicationResp, err error) {
    // 使用熔断器调用RPC服务
    rpcResp, err := breaker.DoWithBreakerResultAcceptable(l.ctx, "loan-rpc", func() (*loanclient.CreateLoanApplicationResp, error) {
        return l.svcCtx.LoanRpc.CreateLoanApplication(l.ctx, &loanclient.CreateLoanApplicationReq{
            UserId:    userId,
            ProductId: req.ProductId,
            // ... 其他参数
        })
    }, breaker.IsAcceptableError)
    
    if err != nil {
        logx.WithContext(l.ctx).Errorf("调用Loan RPC失败: %v", err)
        return nil, err
    }
    
    return &types.CreateLoanApplicationResp{
        ApplicationId: rpcResp.ApplicationId,
    }, nil
}
```

### 2. RPC层使用熔断器

RPC层调用其他RPC服务时也应使用熔断器：

```go
package logic

import (
    "rpc/internal/breaker"
    "appuserrpc/appuserclient"
)

func (l *CreateLoanApplicationLogic) CreateLoanApplication(in *loan.CreateLoanApplicationReq) (*loan.CreateLoanApplicationResp, error) {
    // 使用熔断器调用其他RPC服务
    userResp, err := breaker.DoWithBreakerResultAcceptable(l.ctx, "appuser-rpc", func() (*appuserclient.GetUserInfoResp, error) {
        return l.svcCtx.AppUserClient.GetUserById(l.ctx, &appuserclient.GetUserByIdReq{
            UserId: in.UserId,
        })
    }, breaker.IsAcceptableError)
    
    if err != nil {
        l.Errorf("调用AppUser服务失败: %v", err)
        return nil, fmt.Errorf("用户信息验证失败，请稍后重试")
    }
    
    // 业务逻辑处理...
}
```

### 3. 熔断器方法说明

#### DoWithBreakerResult
基础熔断器方法，用于有返回值的RPC调用：

```go
result, err := breaker.DoWithBreakerResult[ResponseType](ctx, serviceName, func() (ResponseType, error) {
    return rpcClient.Method(ctx, request)
})
```

#### DoWithBreakerResultAcceptable
带自定义错误判断的熔断器方法，推荐使用：

```go
result, err := breaker.DoWithBreakerResultAcceptable[ResponseType](ctx, serviceName, func() (ResponseType, error) {
    return rpcClient.Method(ctx, request)
}, breaker.IsAcceptableError)
```

#### DoWithBreaker
无返回值的熔断器方法：

```go
err := breakerClient.DoWithBreaker(ctx, func() error {
    _, err := rpcClient.Method(ctx, request)
    return err
})
```

### 4. 错误类型处理

熔断器会区分业务错误和系统错误：

- **业务错误**：不计入熔断统计（如参数错误、权限不足、数据不存在等）
- **系统错误**：计入熔断统计（如网络超时、连接失败、服务不可用等）

```go
// 自定义错误判断示例
func IsAcceptableError(err error) bool {
    if err == nil {
        return true
    }
    
    errMsg := err.Error()
    
    // 业务错误关键词 - 不触发熔断
    businessErrors := []string{
        "参数错误",
        "权限不足", 
        "用户不存在",
        "产品不存在",
        "申请不存在",
        "状态错误",
        "重复提交",
        "余额不足",
        "库存不足",
    }
    
    for _, keyword := range businessErrors {
        if strings.Contains(errMsg, keyword) {
            return true // 不计入熔断统计
        }
    }
    
    return false // 计入熔断统计
}
```

## ServiceContext配置

### 1. API层ServiceContext

```go
type ServiceContext struct {
    Config    config.Config
    LoanRpc   loanclient.Loan
    
    // 熔断器客户端
    LoanRpcBreaker *breaker.RpcBreakerClient
}

func NewServiceContext(c config.Config) *ServiceContext {
    return &ServiceContext{
        Config:  c,
        LoanRpc: loanclient.NewLoan(zrpc.MustNewClient(c.LoanRpc)),
        
        // 初始化熔断器
        LoanRpcBreaker: breaker.NewRpcBreakerClient("loan-rpc"),
    }
}
```

### 2. RPC层ServiceContext

```go
type ServiceContext struct {
    Config            config.Config
    LoanProductClient loanproductservice.LoanProductService
    AppUserClient     appuserclient.AppUser
    
    // 熔断器客户端
    LoanProductBreaker *breaker.RpcBreakerClient
    AppUserBreaker     *breaker.RpcBreakerClient
}

func NewServiceContext(c config.Config) *ServiceContext {
    return &ServiceContext{
        Config:            c,
        LoanProductClient: loanproductservice.NewLoanProductService(zrpc.MustNewClient(c.LoanProductRpc)),
        AppUserClient:     appuserclient.NewAppUser(zrpc.MustNewClient(c.AppUserRpc)),
        
        // 初始化熔断器
        LoanProductBreaker: breaker.NewRpcBreakerClient("loanproduct-rpc"),
        AppUserBreaker:     breaker.NewRpcBreakerClient("appuser-rpc"),
    }
}
```

## 熔断器原理

### 1. go-zero熔断器算法

go-zero使用Google SRE算法进行熔断判断：

- **滑动窗口**：10秒窗口，40个桶
- **熔断条件**：基于错误率和响应时间
- **恢复机制**：半开状态下逐步恢复

### 2. 熔断状态

- **CLOSED（关闭）**：正常状态，请求正常通过
- **OPEN（开启）**：熔断状态，请求快速失败
- **HALF_OPEN（半开）**：恢复状态，允许少量请求通过

### 3. 熔断好处

- **快速失败**：避免长时间等待不可用的服务
- **系统保护**：防止级联故障扩散
- **资源节约**：减少无效的资源消耗
- **用户体验**：快速返回友好错误信息

## 最佳实践

### 1. 熔断器命名规范

- 使用服务名作为熔断器名称：`"loan-rpc"`, `"appuser-rpc"`
- 保持命名一致性，便于监控和故障排查

### 2. 错误处理策略

- 区分业务错误和系统错误
- 为业务错误提供具体的错误信息
- 为系统错误提供友好的提示信息

### 3. 监控告警

- 监控熔断器状态变化
- 设置熔断率告警阈值
- 关注服务依赖关系图

### 4. 降级策略

- 准备降级方案：返回默认值、缓存数据等
- 核心服务优先保证可用性
- 非核心功能可以暂时关闭

## 故障排查

### 1. 常见问题

**问题1**：服务启动时连接失败
- **原因**：依赖服务未启动
- **解决**：检查LazyInit配置，确保为true

**问题2**：熔断器频繁触发
- **原因**：依赖服务不稳定或网络问题
- **解决**：检查依赖服务状态和网络连接

**问题3**：业务错误触发熔断
- **原因**：错误分类不准确
- **解决**：优化IsAcceptableError函数

### 2. 日志分析

查看熔断器相关日志：

```bash
# 查看熔断器生效日志
grep "熔断器生效" logs/service.log

# 查看RPC调用失败日志  
grep "RPC调用失败" logs/service.log

# 查看服务启动日志
grep "Starting.*server" logs/service.log
```

### 3. 性能监控

- 监控RPC调用延迟
- 观察熔断器开启频率
- 分析错误率趋势

## 总结

通过配置懒加载和熔断器，可以显著提高微服务系统的健壮性：

1. **懒加载**：解决服务启动依赖问题
2. **熔断器**：防止级联故障，提高系统可用性
3. **错误分类**：准确区分业务错误和系统错误
4. **监控告警**：及时发现和处理问题

正确使用这些机制，可以让微服务系统在面对各种异常情况时保持良好的可用性和用户体验。 