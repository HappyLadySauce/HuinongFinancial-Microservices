// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: lease-rpc.proto

package lease

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Lease_CreateLeaseApplication_FullMethodName  = "/lease.Lease/CreateLeaseApplication"
	Lease_GetLeaseApplication_FullMethodName     = "/lease.Lease/GetLeaseApplication"
	Lease_ListLeaseApplications_FullMethodName   = "/lease.Lease/ListLeaseApplications"
	Lease_UpdateLeaseApplication_FullMethodName  = "/lease.Lease/UpdateLeaseApplication"
	Lease_CancelLeaseApplication_FullMethodName  = "/lease.Lease/CancelLeaseApplication"
	Lease_ApproveLeaseApplication_FullMethodName = "/lease.Lease/ApproveLeaseApplication"
	Lease_ListLeaseApprovals_FullMethodName      = "/lease.Lease/ListLeaseApprovals"
)

// LeaseClient is the client API for Lease service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Lease服务 - 包含租赁申请管理和审批管理
type LeaseClient interface {
	// 租赁申请管理
	CreateLeaseApplication(ctx context.Context, in *CreateLeaseApplicationReq, opts ...grpc.CallOption) (*CreateLeaseApplicationResp, error)
	GetLeaseApplication(ctx context.Context, in *GetLeaseApplicationReq, opts ...grpc.CallOption) (*GetLeaseApplicationResp, error)
	ListLeaseApplications(ctx context.Context, in *ListLeaseApplicationsReq, opts ...grpc.CallOption) (*ListLeaseApplicationsResp, error)
	UpdateLeaseApplication(ctx context.Context, in *UpdateLeaseApplicationReq, opts ...grpc.CallOption) (*UpdateLeaseApplicationResp, error)
	CancelLeaseApplication(ctx context.Context, in *CancelLeaseApplicationReq, opts ...grpc.CallOption) (*CancelLeaseApplicationResp, error)
	// 租赁审批管理
	ApproveLeaseApplication(ctx context.Context, in *ApproveLeaseApplicationReq, opts ...grpc.CallOption) (*ApproveLeaseApplicationResp, error)
	ListLeaseApprovals(ctx context.Context, in *ListLeaseApprovalsReq, opts ...grpc.CallOption) (*ListLeaseApprovalsResp, error)
}

type leaseClient struct {
	cc grpc.ClientConnInterface
}

func NewLeaseClient(cc grpc.ClientConnInterface) LeaseClient {
	return &leaseClient{cc}
}

func (c *leaseClient) CreateLeaseApplication(ctx context.Context, in *CreateLeaseApplicationReq, opts ...grpc.CallOption) (*CreateLeaseApplicationResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateLeaseApplicationResp)
	err := c.cc.Invoke(ctx, Lease_CreateLeaseApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaseClient) GetLeaseApplication(ctx context.Context, in *GetLeaseApplicationReq, opts ...grpc.CallOption) (*GetLeaseApplicationResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLeaseApplicationResp)
	err := c.cc.Invoke(ctx, Lease_GetLeaseApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaseClient) ListLeaseApplications(ctx context.Context, in *ListLeaseApplicationsReq, opts ...grpc.CallOption) (*ListLeaseApplicationsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLeaseApplicationsResp)
	err := c.cc.Invoke(ctx, Lease_ListLeaseApplications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaseClient) UpdateLeaseApplication(ctx context.Context, in *UpdateLeaseApplicationReq, opts ...grpc.CallOption) (*UpdateLeaseApplicationResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateLeaseApplicationResp)
	err := c.cc.Invoke(ctx, Lease_UpdateLeaseApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaseClient) CancelLeaseApplication(ctx context.Context, in *CancelLeaseApplicationReq, opts ...grpc.CallOption) (*CancelLeaseApplicationResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelLeaseApplicationResp)
	err := c.cc.Invoke(ctx, Lease_CancelLeaseApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaseClient) ApproveLeaseApplication(ctx context.Context, in *ApproveLeaseApplicationReq, opts ...grpc.CallOption) (*ApproveLeaseApplicationResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveLeaseApplicationResp)
	err := c.cc.Invoke(ctx, Lease_ApproveLeaseApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaseClient) ListLeaseApprovals(ctx context.Context, in *ListLeaseApprovalsReq, opts ...grpc.CallOption) (*ListLeaseApprovalsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLeaseApprovalsResp)
	err := c.cc.Invoke(ctx, Lease_ListLeaseApprovals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeaseServer is the server API for Lease service.
// All implementations must embed UnimplementedLeaseServer
// for forward compatibility.
//
// Lease服务 - 包含租赁申请管理和审批管理
type LeaseServer interface {
	// 租赁申请管理
	CreateLeaseApplication(context.Context, *CreateLeaseApplicationReq) (*CreateLeaseApplicationResp, error)
	GetLeaseApplication(context.Context, *GetLeaseApplicationReq) (*GetLeaseApplicationResp, error)
	ListLeaseApplications(context.Context, *ListLeaseApplicationsReq) (*ListLeaseApplicationsResp, error)
	UpdateLeaseApplication(context.Context, *UpdateLeaseApplicationReq) (*UpdateLeaseApplicationResp, error)
	CancelLeaseApplication(context.Context, *CancelLeaseApplicationReq) (*CancelLeaseApplicationResp, error)
	// 租赁审批管理
	ApproveLeaseApplication(context.Context, *ApproveLeaseApplicationReq) (*ApproveLeaseApplicationResp, error)
	ListLeaseApprovals(context.Context, *ListLeaseApprovalsReq) (*ListLeaseApprovalsResp, error)
	mustEmbedUnimplementedLeaseServer()
}

// UnimplementedLeaseServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLeaseServer struct{}

func (UnimplementedLeaseServer) CreateLeaseApplication(context.Context, *CreateLeaseApplicationReq) (*CreateLeaseApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLeaseApplication not implemented")
}
func (UnimplementedLeaseServer) GetLeaseApplication(context.Context, *GetLeaseApplicationReq) (*GetLeaseApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLeaseApplication not implemented")
}
func (UnimplementedLeaseServer) ListLeaseApplications(context.Context, *ListLeaseApplicationsReq) (*ListLeaseApplicationsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLeaseApplications not implemented")
}
func (UnimplementedLeaseServer) UpdateLeaseApplication(context.Context, *UpdateLeaseApplicationReq) (*UpdateLeaseApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLeaseApplication not implemented")
}
func (UnimplementedLeaseServer) CancelLeaseApplication(context.Context, *CancelLeaseApplicationReq) (*CancelLeaseApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelLeaseApplication not implemented")
}
func (UnimplementedLeaseServer) ApproveLeaseApplication(context.Context, *ApproveLeaseApplicationReq) (*ApproveLeaseApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveLeaseApplication not implemented")
}
func (UnimplementedLeaseServer) ListLeaseApprovals(context.Context, *ListLeaseApprovalsReq) (*ListLeaseApprovalsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLeaseApprovals not implemented")
}
func (UnimplementedLeaseServer) mustEmbedUnimplementedLeaseServer() {}
func (UnimplementedLeaseServer) testEmbeddedByValue()               {}

// UnsafeLeaseServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeaseServer will
// result in compilation errors.
type UnsafeLeaseServer interface {
	mustEmbedUnimplementedLeaseServer()
}

func RegisterLeaseServer(s grpc.ServiceRegistrar, srv LeaseServer) {
	// If the following call pancis, it indicates UnimplementedLeaseServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Lease_ServiceDesc, srv)
}

func _Lease_CreateLeaseApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLeaseApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaseServer).CreateLeaseApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lease_CreateLeaseApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaseServer).CreateLeaseApplication(ctx, req.(*CreateLeaseApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lease_GetLeaseApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeaseApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaseServer).GetLeaseApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lease_GetLeaseApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaseServer).GetLeaseApplication(ctx, req.(*GetLeaseApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lease_ListLeaseApplications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLeaseApplicationsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaseServer).ListLeaseApplications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lease_ListLeaseApplications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaseServer).ListLeaseApplications(ctx, req.(*ListLeaseApplicationsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lease_UpdateLeaseApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLeaseApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaseServer).UpdateLeaseApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lease_UpdateLeaseApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaseServer).UpdateLeaseApplication(ctx, req.(*UpdateLeaseApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lease_CancelLeaseApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelLeaseApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaseServer).CancelLeaseApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lease_CancelLeaseApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaseServer).CancelLeaseApplication(ctx, req.(*CancelLeaseApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lease_ApproveLeaseApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveLeaseApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaseServer).ApproveLeaseApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lease_ApproveLeaseApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaseServer).ApproveLeaseApplication(ctx, req.(*ApproveLeaseApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lease_ListLeaseApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLeaseApprovalsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaseServer).ListLeaseApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lease_ListLeaseApprovals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaseServer).ListLeaseApprovals(ctx, req.(*ListLeaseApprovalsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Lease_ServiceDesc is the grpc.ServiceDesc for Lease service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Lease_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lease.Lease",
	HandlerType: (*LeaseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLeaseApplication",
			Handler:    _Lease_CreateLeaseApplication_Handler,
		},
		{
			MethodName: "GetLeaseApplication",
			Handler:    _Lease_GetLeaseApplication_Handler,
		},
		{
			MethodName: "ListLeaseApplications",
			Handler:    _Lease_ListLeaseApplications_Handler,
		},
		{
			MethodName: "UpdateLeaseApplication",
			Handler:    _Lease_UpdateLeaseApplication_Handler,
		},
		{
			MethodName: "CancelLeaseApplication",
			Handler:    _Lease_CancelLeaseApplication_Handler,
		},
		{
			MethodName: "ApproveLeaseApplication",
			Handler:    _Lease_ApproveLeaseApplication_Handler,
		},
		{
			MethodName: "ListLeaseApprovals",
			Handler:    _Lease_ListLeaseApprovals_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lease-rpc.proto",
}
